import Mathlib

/-!
# Ruelle brackets

Convention:

 W^+(o)
  |
  u-----‚ÅÖs, u‚ÅÜ
  |       |
  |       |
  |       |
  |       |
--o-------s-- W^-(o)
  |

The stable manifold is the set of points with `‚ÅÖx, o‚ÅÜ = x`, or equivalently `‚ÅÖo, x‚ÅÜ = o`.
The unstable manifold is the set of points with `‚ÅÖo, y‚ÅÜ = y`, or equivalently `‚ÅÖy, o‚ÅÜ = o`.
The stable manifold is represented horizontally and the unstable manifold vertically,
so that the notation `‚ÅÖs, u‚ÅÜ` for a point parameterized by its stable and unstable components is
analogous to a coordinate notation `(s, u)`. Generally, if `p` and `q` are thought of as
two-dimensional, then `‚ÅÖp, q‚ÅÜ = (p.1, q.2)` is the intersection of the vertical line through `p`
and the horizontal line through `q`.
-/

open scoped Uniformity Topology
open Function Set Filter Metric

namespace SmaleSpace

variable (X : Type*) [MetricSpace X] {U V : Set (X √ó X)} {a b c o s u x y z : X} {Œµ : ‚Ñù}

/-! ### Spaces with a Ruelle bracket -/

/-- A Ruelle bracket on a space is a bracket operation `‚ÅÖx, y‚ÅÜ` corresponding to taking the local
intersection of the stable manifold of `x` and the unstable manifold of `y`. It is only defined for
`x` close enough to `y`.

For the formalization, we require the bracket to be defined everywhere although we will only use
it close to the diagonal, to avoid dependent type issues. We record its algebraic properties,
together with uniform continuity.

We include in the definition the data of a size `Œ¥‚ÇÄ` below which the bracket is well defined.
We could require only its existence, but including it as data makes it possible to be more explicit
in concrete situations. For instance, in subshifts of finite type, we can take `Œ¥‚ÇÄ = 1`, meaning
that the bracket is well defined on pairs of points sharing the same symbol at coordinate `0`.
-/
class HasRuelleBracket where
  /-- the bracket itself, denoted `‚ÅÖx, y‚ÅÜ` once the theory is set up -/
  toFun : X ‚Üí X ‚Üí X
  /-- the bracket is only well behaved below some size `Œ¥‚ÇÄ > 0` -/
  deltaZero : ‚Ñù
  deltaZero_pos : 0 < deltaZero
  unifCont : UniformContinuousOn (uncurry toFun) {p | dist p.1 p.2 < deltaZero}
  refl x : toFun x x = x
  bracket_left' : ‚àÄ x y z, dist x y < deltaZero ‚Üí dist y z < deltaZero ‚Üí
    toFun (toFun x y) z = toFun x z
  bracket_right' : ‚àÄ x y z, dist x y < deltaZero ‚Üí dist y z < deltaZero ‚Üí
    toFun x (toFun y z) = toFun x z

instance [h : HasRuelleBracket X] : Bracket X X where
  bracket := h.toFun

export HasRuelleBracket (deltaZero_pos)

local notation3 "Œ¥‚ÇÄ" => HasRuelleBracket.deltaZero X

variable [HasRuelleBracket X]

lemma uniformContinuousOn_bracket :
    UniformContinuousOn (fun (p : X √ó X) ‚Ü¶ ‚ÅÖp.1, p.2‚ÅÜ) {p : X √ó X | dist p.1 p.2 < Œ¥‚ÇÄ} :=
  HasRuelleBracket.unifCont

lemma continuousOn_bracket :
    ContinuousOn (fun (p : X √ó X) ‚Ü¶ ‚ÅÖp.1, p.2‚ÅÜ) {p : X √ó X | dist p.1 p.2 < Œ¥‚ÇÄ} :=
  (uniformContinuousOn_bracket X).continuousOn

variable {X}

@[simp] lemma bracket_self (x : X) : ‚ÅÖx, x‚ÅÜ = x :=
  HasRuelleBracket.refl x

lemma bracket_left (h : dist x y < Œ¥‚ÇÄ) (h' : dist y z < Œ¥‚ÇÄ) :
    ‚ÅÖ‚ÅÖx, y‚ÅÜ, z‚ÅÜ = ‚ÅÖx, z‚ÅÜ :=
  HasRuelleBracket.bracket_left' x y z h h'

lemma bracket_right (h : dist x y < Œ¥‚ÇÄ) (h' : dist y z < Œ¥‚ÇÄ) :
    ‚ÅÖx, ‚ÅÖy, z‚ÅÜ‚ÅÜ = ‚ÅÖx, z‚ÅÜ :=
  HasRuelleBracket.bracket_right' x y z h h'

/-- If `a` and `b` are close, then `a` and `‚ÅÖa, b‚ÅÜ` are close. -/
lemma tendsto_bracket_fst : Tendsto (fun (p : X √ó X) ‚Ü¶ (p.1, ‚ÅÖp.1, p.2‚ÅÜ)) (ùì§ X) (ùì§ X) := by
  intro V hV
  rcases uniformContinuousOn_bracket X hV with ‚ü®t‚ÇÅ, h‚ÇÅ, t‚ÇÇ, h‚ÇÇ, hV'‚ü©
  rcases entourageProd_subset h‚ÇÅ with ‚ü®u, hu, u', hu', huu'‚ü©
  have : {p : X √ó X | dist p.1 p.2 < Œ¥‚ÇÄ} ‚àà ùì§ X := Metric.dist_mem_uniformity deltaZero_pos
  have : {p : X √ó X | dist p.1 p.2 < Œ¥‚ÇÄ} ‚à© u ‚à© u' ‚àà ùì§ X := by grind [Filter.inter_mem]
  apply mem_of_superset this
  rintro ‚ü®a, b‚ü© hab
  have M‚ÇÅ : ((a, a), (a, b)) ‚àà t‚ÇÅ := huu' (by simp [entourageProd, mem_uniformity_of_eq hu, hab.2])
  have M‚ÇÇ : ((a, a), (a, b)) ‚àà t‚ÇÇ := by
    simp only [mem_principal] at h‚ÇÇ
    apply h‚ÇÇ
    simp [deltaZero_pos, hab.1.1]
  have : ((a, a), (a, b)) ‚àà t‚ÇÅ ‚à© t‚ÇÇ := ‚ü®M‚ÇÅ, M‚ÇÇ‚ü©
  simpa [‚Üê hV']

/-- If `a` and `b` are close, then `a` and `‚ÅÖa, b‚ÅÜ` are close. -/
lemma tendsto_bracket_snd : Tendsto (fun (p : X √ó X) ‚Ü¶ (p.2, ‚ÅÖp.1, p.2‚ÅÜ)) (ùì§ X) (ùì§ X) :=
  tendsto_id.uniformity_symm.uniformity_trans tendsto_bracket_fst

/-- If three points are close, then the first one is close to the bracket of the other ones.
Version in terms of uniformities. -/
lemma exists_bracket_mem_entourage (hU : U ‚àà ùì§ X) :
    ‚àÉ V ‚àà ùì§ X, (‚àÄ x y, (x, y) ‚àà V ‚Üí (y, x) ‚àà V) ‚àß
      ‚àÄ x y z, (y, x) ‚àà V ‚Üí (x, z) ‚àà V ‚Üí ((x, ‚ÅÖy, z‚ÅÜ) ‚àà U ‚àß (‚ÅÖy, z‚ÅÜ, x) ‚àà U) := by
  rcases comp_symm_of_uniformity hU with ‚ü®U', U'_mem, U'_symm, hU'‚ü©
  rcases comp_symm_of_uniformity (tendsto_bracket_fst U'_mem) with ‚ü®V, V_mem, V_symm, hV‚ü©
  refine ‚ü®U' ‚à© V, inter_mem U'_mem V_mem, fun x y hxy ‚Ü¶ ‚ü®U'_symm hxy.1, V_symm hxy.2‚ü© ,
    fun x y z hxy hxz ‚Ü¶ ?_‚ü©
  have : (y, ‚ÅÖy, z‚ÅÜ) ‚àà U' := by
    have : (y, z) ‚àà V ‚óã V := prodMk_mem_compRel hxy.2 hxz.2
    exact hV this
  exact ‚ü®hU' (prodMk_mem_compRel (U'_symm hxy.1) this),
    hU' (prodMk_mem_compRel (U'_symm this) hxy.1)‚ü©

variable (X) in
/-- If three points are close, then the first one is clsoe to the bracket of the other ones.
Version in terms of distances. -/
lemma exists_dist_bracket_lt (hŒµ : 0 < Œµ) :
    ‚àÉ Œµ' ‚àà Ioc 0 ((min Œµ Œ¥‚ÇÄ) / 2), ‚àÄ x y z,
      dist x y < Œµ' ‚Üí dist x z < Œµ' ‚Üí dist (x : X) ‚ÅÖy, z‚ÅÜ < Œµ := by
  have := deltaZero_pos (X := X)
  have : {p : X √ó X | dist p.1 p.2 < Œµ} ‚àà ùì§ X := Metric.dist_mem_uniformity hŒµ
  rcases exists_bracket_mem_entourage this with ‚ü®V, hV, -, h'V‚ü©
  rcases Metric.mem_uniformity_dist.1 hV with ‚ü®Œµ', Œµ'_pos, hŒµ'‚ü©
  refine ‚ü®min Œµ' ((min Œµ Œ¥‚ÇÄ) / 2), ‚ü®by positivity, min_le_right _ _‚ü© , fun x y z hxy hxz ‚Ü¶ ?_‚ü©
  refine (h'V _ _ _ (hŒµ' ?_) (hŒµ' (by grind))).1
  rw [dist_comm]
  grind

/-!
### Reducing scales

Given a small scale `Œµ`, we define a smaller scale `reduceScale X Œµ` so that points within the
smaller scale have brackets within distance `Œµ`. We specialize this to `Œ¥‚ÇÅ := reduceScale X Œ¥‚ÇÄ`.
-/

variable (X) in
/-- The scale `reduceScale X Œµ` is small enough compared to `Œµ` so that points within the
smaller scale have brackets within distance `Œµ`.-/
noncomputable def reduceScale (Œµ : ‚Ñù) : ‚Ñù :=
  if hŒµ : 0 < Œµ then (exists_dist_bracket_lt X hŒµ).choose
  else Œµ

lemma reduceScale_pos (hŒµ : 0 < Œµ) : 0 < reduceScale X Œµ := by
  simp only [reduceScale, hŒµ, ‚ÜìreduceDIte]
  exact (exists_dist_bracket_lt X hŒµ).choose_spec.1.1

lemma reduceScale_le_half_self : reduceScale X Œµ ‚â§ Œµ / 2 := by
  by_cases hŒµ : 0 < Œµ
  ¬∑ simp only [reduceScale, hŒµ, ‚ÜìreduceDIte]
    apply (exists_dist_bracket_lt X hŒµ).choose_spec.1.2.trans
    gcongr
    exact min_le_left _ _
  ¬∑ simp only [reduceScale, hŒµ, ‚ÜìreduceDIte]
    linarith

lemma reduceScale_le_half_deltaZero : reduceScale X Œµ ‚â§ Œ¥‚ÇÄ / 2 := by
  by_cases hŒµ : 0 < Œµ
  ¬∑ simp only [reduceScale, hŒµ, ‚ÜìreduceDIte]
    apply (exists_dist_bracket_lt X hŒµ).choose_spec.1.2.trans
    gcongr
    exact min_le_right _ _
  ¬∑ simp only [reduceScale, hŒµ, ‚ÜìreduceDIte]
    linarith [deltaZero_pos (X := X)]

lemma reduceScale_le_deltaZero : reduceScale X Œµ ‚â§ Œ¥‚ÇÄ := by
  linarith [reduceScale_le_half_deltaZero (X := X) (Œµ := Œµ), deltaZero_pos (X := X)]

lemma dist_bracket_lt_of_lt_reduceScale {x y z : X}
    (hxy : dist x y < reduceScale X Œµ) (hxz : dist x z < reduceScale X Œµ) :
    dist x ‚ÅÖy, z‚ÅÜ < Œµ := by
  by_cases hŒµ : 0 < Œµ
  ¬∑ simp only [reduceScale, hŒµ, ‚ÜìreduceDIte] at hxy hxz
    exact (exists_dist_bracket_lt X hŒµ).choose_spec.2 x y z hxy hxz
  ¬∑ simp [reduceScale, hŒµ] at hxy
    linarith [dist_nonneg (x := x) (y := y)]

variable (X) in
/-- A fixed size, sufficiently smaller than `Œ¥‚ÇÄ` to ensure that brackets of points within `Œ¥‚ÇÅ`
remain within `Œ¥‚ÇÄ`. -/
noncomputable def deltaOne : ‚Ñù := reduceScale X Œ¥‚ÇÄ

local notation3 "Œ¥‚ÇÅ" => deltaOne X

lemma deltaOne_pos : 0 < Œ¥‚ÇÅ := reduceScale_pos deltaZero_pos

lemma deltaOne_le_half_deltaZero : Œ¥‚ÇÅ ‚â§ Œ¥‚ÇÄ / 2 := reduceScale_le_half_deltaZero

lemma deltaOne_le_deltaZero : Œ¥‚ÇÅ ‚â§ Œ¥‚ÇÄ := by
  linarith [deltaOne_le_half_deltaZero (X := X), deltaZero_pos (X := X)]

lemma dist_bracket_lt_deltaZero {x y z : X} (hxy : dist x y < Œ¥‚ÇÅ) (hxz : dist x z < Œ¥‚ÇÅ) :
    dist x ‚ÅÖy, z‚ÅÜ < Œ¥‚ÇÄ := dist_bracket_lt_of_lt_reduceScale hxy hxz

/-!
### Local stable and unstable manifolds, local parametrization with product coordinates
-/

/-- The local stable manifold of `o` inside an entourage `U`, defined as the set of points `s` which
are `U`-close to `o` and satisfy `‚ÅÖs, o‚ÅÜ = s`.
Equivalently, these are the points with `‚ÅÖo, s‚ÅÜ = o`, see `locStable_eq`. -/
def locStable (Œµ : ‚Ñù) (o : X) : Set X := {s | dist o s < Œµ ‚àß ‚ÅÖs, o‚ÅÜ = s}

/-- The local unstable manifold of `o` inside an entourage `U`, defined as the set of points `u`
which are `U`-close to `o` and satisfy `‚ÅÖo, u‚ÅÜ = u`.
Equivalently, these are the points with `‚ÅÖu, o‚ÅÜ = o`, see `locUnstable_eq`. -/
def locUnstable (Œµ : ‚Ñù) (o : X) : Set X := {u | dist o u < Œµ ‚àß ‚ÅÖo, u‚ÅÜ = u}

lemma mem_of_mem_locStable (hs : s ‚àà locStable Œµ o) : dist o s < Œµ := hs.1

lemma bracket_eq_of_mem_locStable (hs : s ‚àà locStable Œµ o) : ‚ÅÖs, o‚ÅÜ = s := hs.2

lemma locStable_eq (hŒµ : Œµ ‚â§ Œ¥‚ÇÄ) : locStable Œµ o = {s | dist o s < Œµ ‚àß ‚ÅÖo, s‚ÅÜ = o} := by
  ext s
  have : dist o s = dist s o := PseudoMetricSpace.dist_comm o s
  simp only [locStable, mem_setOf_eq, and_congr_right_iff]
  intro h
  refine ‚ü®fun h' ‚Ü¶ ?_, fun h' ‚Ü¶ ?_‚ü©
  ¬∑ rw [‚Üê h', bracket_right, bracket_self] <;> linarith
  ¬∑ rw [‚Üê h', bracket_right, bracket_self] <;> linarith

lemma mem_of_mem_locUnstable (hu : u ‚àà locUnstable Œµ o) : dist o u < Œµ := hu.1

lemma bracket_eq_of_mem_locUnstable (hu : u ‚àà locUnstable Œµ o) : ‚ÅÖo, u‚ÅÜ = u := hu.2

lemma locUnstable_eq (hŒµ : Œµ ‚â§ Œ¥‚ÇÄ) : locUnstable Œµ o = {u | dist o u < Œµ ‚àß ‚ÅÖu, o‚ÅÜ = o} := by
  ext u
  have : dist o u = dist u o := PseudoMetricSpace.dist_comm o u
  simp only [locUnstable, mem_setOf_eq, and_congr_right_iff]
  intro h
  refine ‚ü®fun h' ‚Ü¶ ?_, fun h' ‚Ü¶ ?_‚ü©
  ¬∑ rw [‚Üê h', bracket_left, bracket_self] <;> linarith
  ¬∑ rw [‚Üê h', bracket_left, bracket_self] <;> linarith

/-- For small enough `Œµ`, one can parametrize a neighborhood of any point `o` by
taking the bracket of points on its stable and unstable manifolds of size `Œµ`.

The fact that the target of this parametrization is indeed a neighborhood of `o` (of
fixed size `reduceScale X Œµ`) is given in `ball_reduceScale_subset_target_localProduct`.
-/
@[simps!]
def localProductEquiv (hŒµ : Œµ ‚â§ Œ¥‚ÇÅ) (o : X) : PartialEquiv (X √ó X) X where
  toFun p := ‚ÅÖp.1, p.2‚ÅÜ
  invFun z := (‚ÅÖz, o‚ÅÜ, ‚ÅÖo, z‚ÅÜ)
  source := (locStable Œµ o) √óÀ¢ (locUnstable Œµ o)
  target := {y | dist o y < Œ¥‚ÇÄ ‚àß dist o ‚ÅÖo, y‚ÅÜ < Œµ ‚àß dist o ‚ÅÖy, o‚ÅÜ < Œµ}
  map_source' := by
    rintro ‚ü®s, u‚ü© ‚ü®hs, hu‚ü©
    have h's : dist o s < Œµ := mem_of_mem_locStable hs
    have h'u : dist o u < Œµ := mem_of_mem_locUnstable hu
    have : dist s u < Œ¥‚ÇÄ := by
      linarith [dist_triangle_left s u o, deltaOne_le_half_deltaZero (X := X)]
    have := deltaOne_le_deltaZero (X := X)
    simp only [mem_setOf_eq]
    refine ‚ü®?_, ?_, ?_‚ü©
    ¬∑ exact dist_bracket_lt_deltaZero (by linarith) (by linarith)
    ¬∑ rwa [bracket_right, bracket_eq_of_mem_locUnstable hu] <;> linarith
    ¬∑ rwa [bracket_left, bracket_eq_of_mem_locStable hs]
      ¬∑ linarith
      ¬∑ rw [dist_comm]
        linarith
  map_target' := by
    rintro x ‚ü®hx_main, hx, h'x‚ü©
    simp only [locStable, locUnstable, mem_prod, mem_setOf_eq, h'x, true_and, hx]
    rw [bracket_left, bracket_right] <;> simp [deltaZero_pos, dist_comm, hx_main]
  left_inv' := by
    rintro ‚ü®s, u‚ü© ‚ü®hs, hu‚ü©
    have h's : dist o s < Œµ := mem_of_mem_locStable hs
    have h'u : dist o u < Œµ := mem_of_mem_locUnstable hu
    have : dist s u < Œ¥‚ÇÄ := by
      linarith [dist_triangle_left s u o, deltaOne_le_half_deltaZero (X := X)]
    have := deltaOne_le_deltaZero (X := X)
    simp only [Prod.mk.injEq]
    constructor
    ¬∑ rw [bracket_left]
      ¬∑ exact bracket_eq_of_mem_locStable hs
      ¬∑ linarith
      ¬∑ rw [dist_comm]
        linarith
    ¬∑ rw [bracket_right]
      ¬∑ exact bracket_eq_of_mem_locUnstable hu
      ¬∑ linarith
      ¬∑ linarith
  right_inv' := by
    intro x ‚ü®hx, h'x, h''x‚ü©
    simp only
    rw [bracket_left, bracket_right, bracket_self]
    ¬∑ rwa [dist_comm]
    ¬∑ exact hx
    ¬∑ rwa [dist_comm]
    ¬∑ linarith [deltaOne_le_deltaZero (X := X)]

lemma continuousOn_localProductEquiv (hŒµ : Œµ ‚â§ Œ¥‚ÇÅ) :
    ContinuousOn (localProductEquiv hŒµ o) (localProductEquiv hŒµ o).source := by
  apply (continuousOn_bracket X).mono
  rintro ‚ü®s, u‚ü© ‚ü®‚ü®hs, h's‚ü©, ‚ü®hu, h'u‚ü©‚ü©
  simp only [mem_setOf_eq] at hs hu ‚ä¢
  linarith [dist_triangle_left s u o, deltaOne_le_half_deltaZero (X := X)]

lemma continuousOn_symm_localProductEquiv (hŒµ : Œµ ‚â§ Œ¥‚ÇÅ) :
    ContinuousOn (localProductEquiv hŒµ o).symm (localProductEquiv hŒµ o).target := by
  apply ContinuousOn.prodMk
  ¬∑ apply (continuousOn_bracket X).comp (Continuous.prodMk_left o).continuousOn
    intro x ‚ü®hxo, hx, h'x‚ü©
    simpa [dist_comm] using hxo
  ¬∑ apply (continuousOn_bracket X).comp (Continuous.prodMk_right o).continuousOn
    intro x ‚ü®hxo, hx, h'x‚ü©
    exact hxo

/-- Given a small enough entourage `U`, the ball around `o` for the smaller
entourage `bracketRoot U` is covered by the local product parametrization coming from `U`.-/
lemma ball_reduceScale_subset_target_localProductEquiv (hŒµ : Œµ ‚â§ Œ¥‚ÇÅ) :
    ball o (reduceScale X Œµ) ‚äÜ (localProductEquiv hŒµ o).target := by
  by_cases hŒµ : 0 < Œµ; swap
  ¬∑ simp only [reduceScale, hŒµ, ‚ÜìreduceDIte, localProductEquiv_target]
    rw [Metric.ball_eq_empty.2 (by linarith)]
    simp
  intro y (hy : dist y o < reduceScale X Œµ)
  rw [dist_comm] at hy
  simp only [localProductEquiv_target, mem_setOf_eq]
  refine ‚ü®?_, ?_, ?_‚ü©
  ¬∑ exact hy.trans_le reduceScale_le_deltaZero
  ¬∑ apply dist_bracket_lt_of_lt_reduceScale _ hy
    simp [reduceScale_pos hŒµ]
  ¬∑ apply dist_bracket_lt_of_lt_reduceScale hy
    simp [reduceScale_pos hŒµ]

lemma target_localProductEquiv_mem_nhds (hŒµ : Œµ ‚â§ Œ¥‚ÇÅ) (h'Œµ : 0 < Œµ) :
    (localProductEquiv hŒµ o).target ‚àà ùìù o := by
  apply mem_of_superset _ (ball_reduceScale_subset_target_localProductEquiv hŒµ)
  exact ball_mem_nhds _ (reduceScale_pos h'Œµ)

end SmaleSpace
